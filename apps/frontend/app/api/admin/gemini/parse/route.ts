import { getSession } from "@/lib/auth";
import { env } from "@/lib/env";
import {
  buildSystemInstruction,
  validateParsedRecipe,
} from "@/lib/recipe-parser/prompt";
import { RECIPE_SCHEMA } from "@/lib/recipe-parser/types";
import { GoogleGenAI } from "@google/genai";
import { NextRequest, NextResponse } from "next/server";

const GEMINI_MODEL = "gemini-2.5-flash";
const POSTGREST_URL = process.env.POSTGREST_URL || "http://localhost:4444";

async function fetchCategories(): Promise<string[]> {
  try {
    const response = await fetch(
      `${POSTGREST_URL}/categories?select=name&order=name`
    );
    if (!response.ok) return [];
    const data = await response.json();
    return data.map((c: { name: string }) => c.name);
  } catch {
    return [];
  }
}

export async function POST(request: NextRequest) {
  try {
    const session = await getSession();

    if (!session) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    if (session.role !== "admin") {
      return NextResponse.json({ error: "Forbidden" }, { status: 403 });
    }

    const body = await request.json();
    const { text } = body;

    if (!text || typeof text !== "string" || !text.trim()) {
      return NextResponse.json(
        { error: "Text is required and must be a non-empty string" },
        { status: 400 }
      );
    }

    const geminiApiKey = env.GEMINI_API_KEY;

    if (!geminiApiKey) {
      return NextResponse.json(
        { error: "Gemini API not configured" },
        { status: 503 }
      );
    }

    // Fetch categories from database
    const categories = await fetchCategories();

    const ai = new GoogleGenAI({ apiKey: geminiApiKey });

    const response = await ai.models.generateContent({
      model: GEMINI_MODEL,
      contents: `Analysera f√∂ljande recepttext:\n\n${text.trim()}`,
      config: {
        systemInstruction: buildSystemInstruction(categories),
        responseMimeType: "application/json",
        responseSchema: RECIPE_SCHEMA,
      },
    });

    const generatedText = response.text;

    if (!generatedText) {
      console.error("No content in Gemini response:", response);
      return NextResponse.json(
        { error: "No content generated by Gemini" },
        { status: 422 }
      );
    }

    let parsedJson: unknown;
    try {
      parsedJson = JSON.parse(generatedText);
    } catch (error) {
      console.error("JSON parse error:", error, "Response:", generatedText);
      return NextResponse.json(
        {
          error: "LLM returned invalid JSON",
          details: generatedText.substring(0, 200),
        },
        { status: 422 }
      );
    }

    try {
      const recipe = validateParsedRecipe(parsedJson);
      return NextResponse.json({ recipe });
    } catch (error) {
      console.error("Recipe validation error:", error);
      console.error("Raw LLM response:", JSON.stringify(parsedJson, null, 2));
      return NextResponse.json(
        {
          error: "LLM response failed validation",
          details: error instanceof Error ? error.message : "Unknown error",
          rawResponse: parsedJson,
        },
        { status: 422 }
      );
    }
  } catch (error) {
    console.error("Parse recipe error:", error);
    return NextResponse.json(
      { error: "Internal server error" },
      { status: 500 }
    );
  }
}
