import { getSession } from "@/lib/auth";
import { env } from "@/lib/env";
import {
  buildSystemInstruction,
  validateParsedRecipe,
} from "@/lib/recipe-parser/prompt";
import { RECIPE_SCHEMA } from "@/lib/recipe-parser/types";
import { GoogleGenAI, Part } from "@google/genai";
import { NextRequest, NextResponse } from "next/server";

const GEMINI_MODEL = "gemini-2.5-flash";
const POSTGREST_URL = process.env.POSTGREST_URL || "http://localhost:4444";
const MAX_IMAGE_SIZE = 10 * 1024 * 1024; // 10MB
const ALLOWED_IMAGE_TYPES = [
  "image/jpeg",
  "image/png",
  "image/webp",
  "image/gif",
];

async function fetchCategories(): Promise<string[]> {
  try {
    const response = await fetch(
      `${POSTGREST_URL}/categories?select=name&order=name`
    );
    if (!response.ok) return [];
    const data = await response.json();
    return data.map((c: { name: string }) => c.name);
  } catch {
    return [];
  }
}

export async function POST(request: NextRequest) {
  try {
    const session = await getSession();

    if (!session) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    if (session.role !== "admin") {
      return NextResponse.json({ error: "Forbidden" }, { status: 403 });
    }

    const contentType = request.headers.get("content-type") || "";
    let text: string | null = null;
    let imageData: { base64: string; mimeType: string } | null = null;

    // Handle FormData (with image) or JSON (text only)
    if (contentType.includes("multipart/form-data")) {
      const formData = await request.formData();
      text = formData.get("text") as string | null;
      const image = formData.get("image") as File | null;

      if (image) {
        // Validate image type
        if (!ALLOWED_IMAGE_TYPES.includes(image.type)) {
          return NextResponse.json(
            {
              error:
                "Ogiltig bildtyp. Tillåtna format: JPEG, PNG, WebP, GIF",
            },
            { status: 400 }
          );
        }

        // Validate image size
        if (image.size > MAX_IMAGE_SIZE) {
          return NextResponse.json(
            { error: "Bilden får vara max 10 MB" },
            { status: 400 }
          );
        }

        // Convert to base64
        const bytes = await image.arrayBuffer();
        const base64 = Buffer.from(bytes).toString("base64");
        imageData = { base64, mimeType: image.type };
      }
    } else {
      const body = await request.json();
      text = body.text;
    }

    // Normalize text input
    const trimmedText =
      text && typeof text === "string" ? text.trim() : null;
    const hasText = trimmedText !== null && trimmedText.length > 0;
    const hasImage = imageData !== null;

    if (!hasText && !hasImage) {
      return NextResponse.json(
        { error: "Text eller bild krävs" },
        { status: 400 }
      );
    }

    const geminiApiKey = env.GEMINI_API_KEY;

    if (!geminiApiKey) {
      return NextResponse.json(
        { error: "Gemini API not configured" },
        { status: 503 }
      );
    }

    // Fetch categories from database
    const categories = await fetchCategories();

    const ai = new GoogleGenAI({ apiKey: geminiApiKey });

    // Build content parts for multimodal input
    const parts: Part[] = [];

    if (imageData) {
      parts.push({
        inlineData: {
          mimeType: imageData.mimeType,
          data: imageData.base64,
        },
      });

      if (trimmedText) {
        parts.push({
          text: `Analysera receptet i bilden. Använd även denna extra information: ${trimmedText}`,
        });
      } else {
        parts.push({
          text: "Analysera receptet i bilden och extrahera all information.",
        });
      }
    } else if (trimmedText) {
      parts.push({
        text: `Analysera följande recepttext:\n\n${trimmedText}`,
      });
    }

    const response = await ai.models.generateContent({
      model: GEMINI_MODEL,
      contents: [{ role: "user", parts }],
      config: {
        systemInstruction: buildSystemInstruction(categories, hasImage),
        responseMimeType: "application/json",
        responseSchema: RECIPE_SCHEMA,
      },
    });

    const generatedText = response.text;

    if (!generatedText) {
      console.error("No content in Gemini response:", response);
      return NextResponse.json(
        { error: "No content generated by Gemini" },
        { status: 422 }
      );
    }

    let parsedJson: unknown;
    try {
      parsedJson = JSON.parse(generatedText);
    } catch (error) {
      console.error("JSON parse error:", error, "Response:", generatedText);
      return NextResponse.json(
        {
          error: "LLM returned invalid JSON",
          details: generatedText.substring(0, 200),
        },
        { status: 422 }
      );
    }

    try {
      const recipe = validateParsedRecipe(parsedJson);
      return NextResponse.json({ recipe });
    } catch (error) {
      console.error("Recipe validation error:", error);
      console.error("Raw LLM response:", JSON.stringify(parsedJson, null, 2));
      return NextResponse.json(
        {
          error: "LLM response failed validation",
          details: error instanceof Error ? error.message : "Unknown error",
          rawResponse: parsedJson,
        },
        { status: 422 }
      );
    }
  } catch (error) {
    console.error("Parse recipe error:", error);
    return NextResponse.json(
      { error: "Internal server error" },
      { status: 500 }
    );
  }
}
