import { getSession } from "@/lib/auth"
import { env } from "@/lib/env"
import {
  RESTRUCTURE_SCHEMA,
  buildRestructureSystemInstruction,
  formatIngredientsForPrompt,
  validateRestructuredIngredients,
  convertToUpdateFormat,
} from "@/lib/ingredient-restructure"
import type { Recipe } from "@/lib/types"
import { GoogleGenAI } from "@google/genai"
import { NextRequest, NextResponse } from "next/server"

const GEMINI_MODEL = "gemini-2.5-flash"
const POSTGREST_URL = process.env.POSTGREST_URL || "http://localhost:4444"

/**
 * POST /api/admin/restructure/preview
 * Generates a preview of how ingredients would be restructured using Gemini.
 *
 * Body:
 * - recipeId: The recipe ID to restructure
 */
export async function POST(request: NextRequest) {
  try {
    const session = await getSession()

    if (!session) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 })
    }

    if (session.role !== "admin") {
      return NextResponse.json({ error: "Forbidden" }, { status: 403 })
    }

    const body = await request.json()
    const { recipeId, instructions } = body

    if (!recipeId || typeof recipeId !== "string") {
      return NextResponse.json(
        { error: "recipeId is required" },
        { status: 400 }
      )
    }

    const customInstructions = typeof instructions === "string" ? instructions.trim() : ""

    // Fetch the recipe
    const recipeResponse = await fetch(
      `${POSTGREST_URL}/recipes_and_categories?id=eq.${recipeId}`
    )

    if (!recipeResponse.ok) {
      return NextResponse.json(
        { error: "Failed to fetch recipe" },
        { status: 500 }
      )
    }

    const recipes: Recipe[] = await recipeResponse.json()

    if (recipes.length === 0) {
      return NextResponse.json(
        { error: "Recipe not found" },
        { status: 404 }
      )
    }

    const recipe = recipes[0]

    if (!recipe.ingredients || recipe.ingredients.length === 0) {
      return NextResponse.json(
        { error: "Recipe has no ingredients" },
        { status: 400 }
      )
    }

    // Check Gemini API key
    const geminiApiKey = env.GEMINI_API_KEY

    if (!geminiApiKey) {
      return NextResponse.json(
        { error: "Gemini API not configured" },
        { status: 503 }
      )
    }

    // Build the prompt
    const ingredientGroups = recipe.ingredient_groups || []
    const recipeInstructions = recipe.instructions || []
    const promptText = formatIngredientsForPrompt(
      recipe.name,
      recipe.description,
      recipe.ingredients,
      ingredientGroups,
      recipeInstructions
    )

    // Add custom instructions if provided
    let fullPrompt = `Strukturera om följande ingredienser:\n\n${promptText}`
    if (customInstructions) {
      fullPrompt += `\n\nYTTERLIGARE INSTRUKTIONER FRÅN ANVÄNDAREN:\n${customInstructions}`
    }

    // Call Gemini
    const ai = new GoogleGenAI({ apiKey: geminiApiKey })

    const response = await ai.models.generateContent({
      model: GEMINI_MODEL,
      contents: fullPrompt,
      config: {
        systemInstruction: buildRestructureSystemInstruction(),
        responseMimeType: "application/json",
        responseSchema: RESTRUCTURE_SCHEMA,
      },
    })

    const generatedText = response.text

    if (!generatedText) {
      console.error("No content in Gemini response:", response)
      return NextResponse.json(
        { error: "No content generated by Gemini" },
        { status: 422 }
      )
    }

    // Parse and validate the response
    let parsedJson: unknown
    try {
      parsedJson = JSON.parse(generatedText)
    } catch (error) {
      console.error("JSON parse error:", error, "Response:", generatedText)
      return NextResponse.json(
        {
          error: "LLM returned invalid JSON",
          details: generatedText.substring(0, 500),
        },
        { status: 422 }
      )
    }

    try {
      const restructured = validateRestructuredIngredients(parsedJson)
      const updateFormat = convertToUpdateFormat(restructured)

      return NextResponse.json({
        recipe: {
          id: recipe.id,
          name: recipe.name,
        },
        current: {
          ingredient_groups: recipe.ingredient_groups,
          ingredients: recipe.ingredients,
        },
        restructured,
        updateFormat,
      })
    } catch (error) {
      console.error("Validation error:", error)
      console.error("Raw LLM response:", JSON.stringify(parsedJson, null, 2))
      return NextResponse.json(
        {
          error: "LLM response failed validation",
          details: error instanceof Error ? error.message : "Unknown error",
          rawResponse: parsedJson,
        },
        { status: 422 }
      )
    }
  } catch (error) {
    console.error("Preview restructure error:", error)
    return NextResponse.json(
      { error: "Internal server error" },
      { status: 500 }
    )
  }
}
